Dans  la plupart des organisations, on cherche à sortir un produit pour régler des problèmes d’utilisateurs, ou de décideurs d’achats. Pour ce faire, nous avons des fonctionnalités à implémenter. Et très rapidement, on cherche à optimiser le flux de fonctionnalités.  Pourquoi ? Parce que c’est facile !

Imaginez cette banque, qui cherche à régler les problèmes de ses conseillers, voire de ses clients, qui a employé des spécialistes pour formaliser ces besoins en un backlog, qui a lancé un appel d’offre et organisé des ateliers pour sélectionner un progiciel et le projet pour le personnaliser, qui a embauché une équipe pour réaliser ce projet, qui a mis en place les contraintes pour s’assurer que l’éditeur et l’équipe projet réalisent ce qui est demandé en temps et en heure, qui a monté et démonté toutes ces équipes au fur et à mesure de l’avancement du projet; imaginez, donc, cette banque, avoir fait tout ça, mais finalement donner un accès direct aux équipes à ses utilisateurs, et ainsi remettre en permanence en cause tout ce qui a été fait jusque là, en mesurant directement la satisfaction des utilisateurs (et des acheteurs).

Soyons sérieux, bande de hippies, nous avons du pain sur la planche. Alors mesurons plutôt ce qui est facilement mesurable, à savoir ce qui est produit par l’équipe. Ça sera des story points, des jours.homme, des lignes de code, des tests verts dans la campagne, peu importe. On mesure des choses qu’on accumule sur des choses accumulées.

Jeff  Patton nous apprend que l’objectif est d’optimiser le résultat (i.e. les changements de comportements) pour améliorer l’impact (i.e. les conséquences pour l'organisation), tout en **minimisant la production**. Il s’agit d’obtenir le maximum d’impact en produisant le moins possible.

Comment faire concrètement ?

# Validation
L’objectif est d’avancer calmement, de vérifier l’utilité de ce qu’on produit, de consolider les fondations avant d’ajouter de nouveaux étages.

Comme dit Jim Benson, un logiciel est terminé comme la pelouse est tondue. Le logiciel devient intéressant quand il arrive dans les mains des utilisateurs, et est terminé quand il est décommissioné. Officialisez cela, en ajoutant une étape de validation/compréhension/apprentissage/retour à la fin.

En fait, une fonctionnalité n'est pas du code à produire, c'est une hypothèse en vue d'obtenir un résultat. John Cutler insiste pour qu'on parle de paris. Une fois le code libéré, il s'agit d'en évaluer les conséquences, et de décider comment continuer à partir de là (c'est parfait on s'arrête là, on va essayer de modifier telle ou telle chose, on a besoin d'autres infos, on désactive ou supprime tout ça, etc).

Vous noterez au passage que si on doute, comme on le devrait, de l'utilité d'une fonctionnalité, il vaut mieux limiter le nombre d'expériences à lancer en parallèle. En sachant qu'une expérience mettra nécessairement un certain temps à livrer ses secrets. Ce délai est d'ailleurs un sujet de réflexion intéressant, notamment pour comprendre que les expériences dont on parle ne sont pas scientifiques stricto sensu (cynefin parle plutôt de sondage).

# Pull system

Posez des limites d'encours sur toutes les étapes du flux, étude/priorisation comprises. Il s'agit de ne préparer un item pour l'étape suivante que quand cette étape est prête à le recevoir. On voit bien que le backlog ne grossira pas plus que de raison en adoptant ce comportement:

* la première étape est une liste priorisée de problèmes, de suppositions, d'idées, de souhaits, et ces sujets seront pris, par ordre de priorité, quand on a la place de les prendre, c'est à dire quand c'est utile d'en pousser la réflexion.
* ce n'est qu'à ce moment-là qu'on va poursuivre l'étude: "à quoi ça sert", découpage, précision de l'objectif et des contraintes, partage de compréhension, etc, puis développement si besoin, et tout ce que ça entraîne de tests, déploiement, etc.
* de proche en proche, on tire ainsi les fonctionnalités depuis la dernière étape: l'impact à avoir sur le monde

# Conclusion

Et si, dans vos outils quotidiens, les fonctionnalités que vous utilisez chaque jour étaient parfaitement adaptées à vos attentes ? Et si vous aviez ces fonctionnalités sous les yeux, plutôt qu’au fond de menus de sous-menus de fonctionnalités plus ou moins cohérentes que vous n’utilisez jamais ? Prenez le temps d’identifier et de valider vos hypothèses, de faire des recherches et des tests avec vos utilisateurs et les parties prenantes. Vous gagnerez du temps.